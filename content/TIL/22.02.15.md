---
emoji: ❗
title: 22.02.15 TIL
date: '2022-02-15 00:00:00'
author: 95Donguk
tags: TIL
categories: TIL
---

# 디자인 패턴 핵심 정리

디자인 패턴은 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법의 하나로 과거 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재사용하기 좋은 형태로 정리한 것

|용도|특징 및 종류|
|:---:|:---|
|생성 패턴|객체 생성 방식을 결정하는 패턴<br>프로토타입 패턴, 싱글톤 패턴, 빌더 패턴, 팩토리 메서드 패턴, 추상 팩토리 패턴|
|구조 패턴|객체를 조직화하는데 유용한 패턴(합성에 관여)<br>브릿지 패턴, 컴포짓 패턴, 어댑터 패턴, 데코레이터 패턴, 퍼사드 패턴, 프록시 패턴, 플라이웨이트 패턴|
|행동 패턴|객체들이 상호작용을 조정 관리하는 패턴<br>커맨드 패턴, 인터프리터 패턴, 메멘토 패턴, 옵저버 패턴, 이터레이터 패턴, 중재자 패턴, 상태 패턴, 전략 패턴, 방문자 패턴, 템플릿 메서드 패턴, 책임 연쇄 패턴|

## 생성 패턴

### 프로토타입 패턴(Prototype Pattern)
* 미리 만들어진 객체를 복제하여 새로운 객체를 생성하는 패턴이다.

* 객체 생성에 원형이 되는 견본을 이용하는 패턴이다.

* 다수의 객체 생성 비용을 효과적으로 줄일 수 있다.

### 싱글톤 패턴(Singleton Pattern)
* 어떤 클래스에 대한 객체는 오직 하나임을 보장하는 패턴이다.

* 생성된 객체에 접근할 수 있는 전역적인 접근점을 제공하는 패턴이다.

### 빌더 패턴(Builder Pattern)
* 복합 객체를 생성하는 방법과 객체를 조립하는 방법을 분리하는 것이 목적이다.

* 복합 객체를 생성하는 절차를 좀 더 세밀하게 나눌 수 있다.

* 동일한 객체 생성 절차에서 조립 방법에 따라 다른 결과를 만들 수 있게 하는 패턴이다.

* 객체 조립 순서에 따라 다른 결과를 만들 수 있게 하는 패턴이다.

### 팩토리 메서드 패턴(Factory Method Pattern)
* 모든 **객체 생성을 팩토리 클래스에 위임하는 패턴**이다.

* 팩토리 클래스를 만드는 패턴이다.

* **객체 생성하는 시점을 자식클래스로 미루는 패턴**이다.

* 조건에 따라 객체를 다르게 생성해야 할 때 사용할 수 있다.

### 추상 팩토리 패턴(Abstract Factory Pattern)
* 구체적 클래스는 지정하지 않고, 서로 관련이 있는 구성요소별로 **객체 집합을 생성**한다.

* 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴이다.

* 팩토리 메서드 패턴을 좀 더 캡슐화한 방식이라고 볼 수 있다.

## 구조 패턴

### 브릿지 패턴(Bridge Pattern)
* 구현부에서 추상층를 분리하여 각각 독립적으로 변형할 수 있는 패턴이다.

* 추상과 구현을 분리하여 각각 독립적으로 변경해도 서로 영향을 주지 않는다.

### 컴포짓 패턴(Composite Pattern)
* 0개 또는 그 이상의 객체를 묶어 **하나의 객체**로 이용한다.

* 복합 개체와 단일 개체를 같은 방법으로 사용할 수 있는 패턴이다.

* **트리 구조**로 관리하고자 할 때 자주 사용이 된다.
    * 예 : 폴더(복합 개체)와 파일(단일 개체)을 같은 방법으로 사용할 수 있는 패턴이다.

### 어댑터 패턴(Adapter Pattern)
* 인터페이스를 사용자가 기대하는 **다른 인터페이스로 변환**하는 패턴이다.

* 객체를 감싸서 다른 인터페이스를 제공한다.(Wrapper pattern이라고도 함)

* 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 다른 클래스의 인터페이스를 기존 인터페이스에 덧붙인다.

* 일관성 있는 인터페이스를 사용할 수 있도록 한다.

### 데코레이터 패턴(Decorator Pattern)
* **상속을 사용하지 않고 객체의 기능을 동적으로 확장**할 수 있다.

* 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴이다.

### 퍼사드 패턴(Facade Pattern)
* 많은 분량의 코드에 접근할 수 있는 **단순한 인터페이스**를 제공

* 서브시스템에 있는 인터페이스의 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴이다.

* 서브시스템에 있는 객체들을 사용할 수 있도록 인터페이스 역할을 한다.

* 서브시스템의 가장 앞쪽에 위치하여 인터페이스 역할을 한다.

### 프록시 패턴(Proxy Pattern)
* 실제 기능을 수행하는 객체 대신 가상의 객체를 사용하여 흐름을 제어하는 패턴이다.

* 어떤 객체에 대한 접근통제를 위해 그 객체의 **대리자(Surrogate)를 제공**하는 패턴이다.

### 플라이웨이트 패턴(Flyweight Pattern)
* 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴이다.

* 객체의 상태를 공유 풀(pool)에 형성하여 **메모리 절약**하기 위한 패턴이다.

## 행동 패턴

### 커맨드 패턴(Command Pattern)
* **요청 자체를 캡슐화** 한다.

* 이를 통해 요청이 서로 다른 사용자(client)를 매개변수로 만들고, 요청을 대기시키거나 로깅(logging)하여 되돌릴 수 있는 연산을 지원한다.

* 명령 패턴은 명령(command), 수신자(receiver), 발동자(invoke), 클라이언트로 구성된다.

### 인터프리터 패턴(Interpreter Pattern)
* 데이터를 주고받을 때, **쉽게 데이터를 해석할 수 있도록 정의**하는 패턴이다.

* 보통 서버와 클라이언트 사이의 데이터 통신에는 문자열이나 비트를 사용한다. 문자열 하나의 패턴으로 등록하여, 코드 내에서 사용할 수 있도록 규격화 작업이 필요하다. 이런 작업을 수행하는 패턴이 인터프리터 패턴이다.

* 인터프리터 패턴은 언어의 문법을 클래스로 표현한다.

* 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴이다.

### 메멘토 패턴(Memento Pattern)
* 객체의 상태 보존과 관련이 있다.

* **객체를 이전 상태로 되돌릴 수 있는 기능**을 제공하는 패턴이다.

* 메멘토 패턴은 롤백(rollback)을 이용하여 실행을 취소한다.

### 옵저버 패턴(Observer Pattern)
* 어떤 **객체의 상태가 변할 때** 그 객체의 의존성을 가진 다른 객체들이 **그 변화를 통지받고 자동으로 갱신**될 수 있게 만드는 패턴이다.

* 객체 사이에 일대다의 의존관계를 정의하고, 어떤 객체의 상태가 변할 때 이 객체와 의존관계인 다른 객체들이 그 변화를 통지받고 자동 갱신될 수 있게 만드는 패턴이다.

### 이터레이터 패턴(Iterator Pattern)
* 어떤 **집합체의 구성요소들을 차례로 접근하기 위한 것이다.**
    * 집합체는 배열, 연결리스트, 스택, 큐 등을 의미한다.

* 내부표현을 노출하지 않고, 집합체 원소들의 접근 방법을 제공하는 패턴이다.

### 중재자 패턴(Mediator Pattern)
* 조정자 패턴이라고도 한다.

* 이 패턴을 사용하면 객체 사이의 통신은 중재자 객체 안에 함축된다.

* 객체들은 더는 다른 객체와 서로 직접 통신하지 않으며 대신 중재자를 통해 통신한다.

* 이 패턴은 **객체 사이의 관계가 매우 복잡**하여 객체 재사용에 부담 갈 경우에 사용한다.

### 상태 패턴(State Pattern)
* 객체지향방식으로 **상태기계를 구현하는 패턴**이다.

* 객체의 내부상태에 따라 스스로 행동을 변경할 수 있도록 허가하는 패턴이다.

* 객체는 마치 자신의 클래스를 바꾸는 것처럼 보인다.

### 전략 패턴(Strategy Pattern)
* **알고리즘 교체**에 유용(알고리즘 변형이 필요한 경우에 유용)

* 이 패턴은 알고리즘을 객체화하여 같은 문제에 다양한 알고리즘을 적용할 수 있다.

* 동일 계열의 알고리즘 군을 정의하고, 각 알고리즘은 캡슐화하며, 각 알고리즘들이 상호교환할 수 있도록 만드는 패턴이다.

### 방문자 패턴(Visitor Pattern)
* **알고리즘을 객체구조에서 분리**시키는 패턴이다.

* 알고리즘을 분리하면 객체구조를 수정하지 않고도 새로운 연산을 정의할 수 있다.

* 실질적으로 새로운 연산을 기존의 객체구조에 추가할 수 있다. 

* 개방-폐쇄 원칙을 적용하는 하나의 방법이다.

### 템플릿 메서드 패턴(Template Method Pattern)
* **알고리즘의 뼈대를 정의**하는 패턴이다.

* 알고리즘 구조를 변경하지 않고 알고리즘의 각 단계들을 다시 정의할 수 있도록 한다.

* 각 단계의 처리를 자식클래스에서 재정의할 수 있다.

### 책임 연쇄 패턴(Chain Of Responsibility Pattern)
* 명령 객체와 일련의 처리 객체를 포함하는 패턴이다.
    * 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이다.

* 객체는 연결리스트처럼 체인을 형성한다.

* 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴이다.

* 요청을 처리할 기회를 하나 이상의 객체에 부여한다.

* 요청을 받을 수 있는 객체를 체인으로 묶고, 실제 요청을 처리하는 객체를 만날 때까지 객체 체인을 따라서 요청을 전달한다.

* 이 패턴은 책임을 다른 객체에 떠넘기는 것과 같다.

## 디자인 패턴 적용 규칙
1. 결합(Coupling)을 최소화한다.
    * 어떤 하나의 클래스 변화가 전체 클래스를 변화시키지 않도록 해야 한다.

    * God Class를 만들지 않는다.(God Class: 다수의 기능을 처리하는 클래스 -> Bad Class)

2. 상속(inheritance)이 아니라 위임(delegation)을 이용하여 프로그래밍한다.
    * 객체지향 프로그램에서 상속을 남용하는 것을 좋지 않다.

    * 위임은 상속의 문제점을 해결할 수 있는 대안이다.

3. 인터페이스(interface)를 이용하여 프로그래밍한다.
    * 인터페이스를 이용한다는 것은 구현된 클래스를 직접 이용하지 않는다는 것이다. 다르게 말하면, 인터페이스에 선언된 메서드를 호출하는 원리로 프로그래밍한다.

    * 인터페이스를 이용하면 구현한 클래스 내부 변화에 영향을 받지 않는다.

    * 구현(implementation) 클래스를 직접 이용하면, 프로그램 변경이 어렵게 된다.
        * 프로그램 변경이 어렵다는 것은 유지보수가 어렵다는 것이다.

### 인터페이스
* 인터페이스는 일관된 공통 특징과 의무의 선언을 나타내는 클래스
* 인터페이스는 선언이므로 즉각적으로 사용할 수 없다.
* 인터페이스는 계약을 명시한다.
* 인터페이스를 실현하는 클래스는 인터페이스에 선언된 그 계약을 이행해야 한다.
* 인터페이스는 다수의 서로 다른 클래스에 의해 구현될 수 있다.

## 디자인 패턴 장단점
|장점|단점|
|:---:|:---:|
|코드 품질 향상<br>시스템 개발에 공통 언어 역할을 한다<br>유지보수 용이<br>향후 변화에 대비할 수 있다|잘못 사용된 패턴은 개발 생산성을 저하시킨다<br>잘못 해석된 패턴은 재사용성을 저하시킨다<br>잘못 사용된 패턴은 유지보수를 저하시킨다<br>설계자가 패턴을 숙지하는데 오랜 시간이 필요하다.


***
## 💡 틀렸거나 잘못된 정보가 있다면 망설임 없이 댓글로 알려주세요!

